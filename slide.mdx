import { CodeSurfer } from "mdx-deck-code-surfer";
export { default as theme } from "./theme";

# React

## 16.3 - 16.7(alpha)

---

# Contexto

## (n√£o a API de contexto, contexto mesmo, tipo contextualizar)

---

# React 16.0, Fiber, async rendering

---

<img src={require("file-loader!./assets/stack_reconciliation.png")}/>
<p style={{ fontSize: "0.6em"}}>(Stack reconciliation‚Ää‚Äî‚Ää√© preciso terminar a atualiza√ß√£o antes de retornar para a main thread (cr√©dito: Lin Clark))</p>
---
<img src={require("file-loader!./assets/fiber_reconciliation.png")}/>
<p style={{ fontSize: "0.6em"}}>(Fiber reconciliation‚Ää‚Äî‚Ääas atualiza√ß√µes ser√£o feitas em peda√ßos (cr√©dito: Lin Clark))</p>
---
import { TwitterTweetEmbed } from "react-twitter-embed";

<TwitterTweetEmbed tweetId={"909926793536094209"} />

```notes
Aqui √© poss√≠vel verificar como o circulo de loading no canto superior direito para de ser renderizado enquanto a √†rvore de componentes √© montada
```

---

# React 16.3

---

<CodeSurfer
  title="Context API"
  code={require("!raw-loader!./samples/contextApi.jsx")}
  showNumbers={false}
  dark={false}
  steps={[
    {},
    { lines: [1], notes: "Cria o contexto" },
    { range: [3, 13], notes: "Exemplo de componente que fornece contexto" },
    { range: [8, 10], notes: "Provider" },
    { range: [15, 23], notes: "Exemplo de componente que consome contexto" },
    { range: [18, 20], notes: "Consumer" },
    { range: [25, 31], notes: "Exemplo de uso" },
    { range: [27, 29], notes: "O consumidor deve estar abaixo de um provider na √°rvore" },
  ]}
/>
---
<CodeSurfer
  title="createRef"
  code={require("!raw-loader!./samples/createRef.jsx")}
  showNumbers={false}
  dark={false}
  steps={[
    {},
    { range: [3, 28], notes: "At√© ent√£o, para se consumir refer√™ncias a elementos da DOM ou outros componentes React, usava-se callback refs" },
    { lines: [19], notes: "Nele, a propriedade ref espera uma fun√ß√£o que recebe a refer√™ncia ou null (quando se desmonta o componente)" },
    { range: [30, 55], notes: "O createRef √© uma nova API que simplifica o acesso a refer√™ncias" },
    { lines: [32], notes: "Para usar, se cria um objeto Ref de antem√£o" },
    { lines: [46], notes: "O objeto √© passado pra propriedade ref" },
    { range: [36, 38], notes: "E a refer√™ncia pode ser acessada na propriedade current do objeto Ref" }
  ]}
/>
---
<CodeSurfer
  title="fowardRef"
  code={require("!raw-loader!./samples/forwardRef.jsx")}
  showNumbers={false}
  dark={false}
  steps={[
    {},
    { lines: [3], notes: "forwardRef recebe um componente funcional e passa para ele um `ref` como segundo argumento"},
    { lines: [4], notes: "Esse ref pode ser passado para outros componentes, React ou nativos"},
    { range: [21, 27], notes: "O componente pode ser usado normalmente" },
    { lines: [4], notes: "Mas o conte√∫do do `ref` ser√° o <input/>, j√° que ele recebeu o `ref` de forwardRef" },
    { lines: [13], notes: "O que permite que se d√™ foco ao <input/> üéâ" },
  ]}
/>
---
# Novos lifecycles
üôÖ UNSAFE_componentWillReceiveProps üôÖ  
üôÖ UNSAFE_componentWillUpdate  üôÖ  
üôÖ UNSAFE_componentWillMount  üôÖ  
üòç getDerivedStateFromProps  üòç  
üòç getSnapshotBeforeUpdate  üòç  

```notes
For example, with the current API, it is too easy to block the initial render with non-essential logic. In part this is because there are too many ways to accomplish a given task, and it can be unclear which is best. We‚Äôve observed that the interrupting behavior of error handling is often not taken into consideration and can result in memory leaks (something that will also impact the upcoming async rendering mode). The current class component API also complicates other efforts, like our work on prototyping a React compiler.

Many of these issues are exacerbated by a subset of the component lifecycles (componentWillMount, componentWillReceiveProps, and componentWillUpdate). These also happen to be the lifecycles that cause the most confusion within the React community. For these reasons, we are going to deprecate those methods in favor of better alternatives.

We are adding the following lifecycle aliases: UNSAFE_componentWillMount, UNSAFE_componentWillReceiveProps, and UNSAFE_componentWillUpdate. (Both the old lifecycle names and the new aliases will be supported.)

We are introducing two new lifecycles, static getDerivedStateFromProps and getSnapshotBeforeUpdate.

getDerivedStateFromProps is being added as a safer alternative to the legacy componentWillReceiveProps. (Note that in most cases you don‚Äôt need either of them.)
getSnapshotBeforeUpdate is being added to support safely reading properties from e.g. the DOM before updates are made.
```
---
<CodeSurfer
  title="getDerivedStateFromProps"
  code={require("!raw-loader!./samples/getDerivedStateFromProps.jsx")}
  showNumbers={false}
  dark={false}
  steps={[
    {},
    {range: [7, 15]}
  ]}
/>

```notes
Deriving state leads to verbose code and makes your components difficult to think about.
Make sure you‚Äôre familiar with simpler alternatives:

If you need to perform a side effect (for example, data fetching or an animation) in response to a change in props, use componentDidUpdate lifecycle instead.

If you want to re-compute some data only when a prop changes, use a memoization helper instead.

If you want to ‚Äúreset‚Äù some state when a prop changes, consider either making a component fully controlled or fully uncontrolled with a key instead.
``` 
---
<CodeSurfer
  title="getSnapshotBeforeUpdate"
  code={require("!raw-loader!./samples/getSnapshotBeforeUpdate.jsx")}
  showNumbers={false}
  dark={false}
  steps={[
    {},
    {range: [7, 13]},
    {range: [15, 20]}
  ]}
/>

```notes
Deriving state leads to verbose code and makes your components difficult to think about.
Make sure you‚Äôre familiar with simpler alternatives:

If you need to perform a side effect (for example, data fetching or an animation) in response to a change in props, use componentDidUpdate lifecycle instead.

If you want to re-compute some data only when a prop changes, use a memoization helper instead.

If you want to ‚Äúreset‚Äù some state when a prop changes, consider either making a component fully controlled or fully uncontrolled with a key instead.
``` 

---
# Strict Mode
---
# React 16.4
---
# Pointer Events
```notes
Pointer events are DOM events that are fired for a pointing device. They are designed to create a single DOM event model to handle pointing input devices such as a mouse, pen/stylus or touch (such as one or more fingers).
```
---
# "Bugfix" para getDerivedStateFromProps
```notes
getDerivedStateFromProps is now called every time a component is rendered, regardless of the cause of the update. Previously, it was only called if the component was re-rendered by its parent, and would not fire as the result of a local setState. This was an oversight in the initial implementation that has now been corrected. The previous behavior was more similar to componentWillReceiveProps, but the improved behavior ensures compatibility with React‚Äôs upcoming asynchronous rendering mode.
```
---
# React 16.5
---
# Profiler
<img src={require("file-loader!./assets/profiler.png")}/>
---
# React 16.6
---
# React.memo
<CodeSurfer
  title="React.memo"
  code={require("!raw-loader!./samples/memo.jsx")}
  showNumbers={false}
  dark={false}
  steps={[
    { range: [1, 5], notes: "Como √© em classes" },
    { range: [7, 9], notes: "E agora a nova feature para fun√ß√µes..." },
  ]}
/>
```notes
Class components can bail out from rendering when their input props are the same using PureComponent or shouldComponentUpdate. Now you can do the same with function components by wrapping them in React.memo.
```
---
<CodeSurfer
  title="Code-Splitting Suspense"
  code={require("!raw-loader!./samples/code-splitting-suspense.jsx")}
  showNumbers={false}
  dark={false}
/>
---
<CodeSurfer
  title="ContextType"
  code={require("!raw-loader!./samples/static-context-type.jsx")}
  showNumbers={false}
  dark={false}
  steps={[
    {},
    { lines: [1], notes: "Inst√¢ncia do contexto" },
    { lines: [4], notes: "Atribui√ß√£o do contexto" },
    { lines: [6], notes: "Consultando contexto" },
  ]}
/>

```notes
We‚Äôve heard feedback that adopting the new render prop API can be difficult in class components. So we‚Äôve add a convenience API to consume a context value from within a class component.
```

---

# React 16.7 (alpha)

---

# Hooks

---

# O Problema

---

# A Solu√ß√£o

---

# Concurrent React

---

# Time-slicing

---

# Suspense
