import { CodeSurfer } from "mdx-deck-code-surfer";

# React

## 16.3 - 16.7(alpha)

---

# Contexto

## (não a API de contexto, contexto mesmo, tipo contextualizar)

---

# React 16.0, Fiber, async rendering

---

<img src={require("file-loader!./assets/stack_reconciliation.png")}/>
<p style={{ fontSize: "0.6em"}}>(Stack reconciliation — é preciso terminar a atualização antes de retornar para a main thread (crédito: Lin Clark))</p>
---
<img src={require("file-loader!./assets/fiber_reconciliation.png")}/>
<p style={{ fontSize: "0.6em"}}>(Fiber reconciliation — as atualizações serão feitas em pedaços (crédito: Lin Clark))</p>
---
import { TwitterTweetEmbed } from "react-twitter-embed";

<TwitterTweetEmbed tweetId={"909926793536094209"} />

```notes
Aqui é possível verificar como o circulo de loading no canto superior direito para de ser renderizado enquanto a àrvore de componentes é montada
```

---

# React 16.3

---

<CodeSurfer
  title="Context API"
  code={require("!raw-loader!./samples/contextApi.jsx")}
  showNumbers={false}
  dark={false}
  steps={[
    {},
    { lines: [1], notes: "Cria o contexto" },
    { range: [3, 13], notes: "Exemplo de componente que fornece contexto" },
    { range: [8, 10], notes: "Provider" },
    { range: [15, 23], notes: "Exemplo de componente que consome contexto" },
    { range: [18, 20], notes: "Consumer" },
    { range: [25, 31], notes: "Exemplo de uso" },
    { range: [27, 29], notes: "O consumidor deve estar abaixo de um provider na árvore" },
  ]}
/>
---
<CodeSurfer
  title="createRef"
  code={require("!raw-loader!./samples/createRef.jsx")}
  showNumbers={false}
  dark={false}
  steps={[
    {},
    { range: [3, 28], notes: "Até então, para se consumir referências a elementos da DOM ou outros componentes React, usava-se callback refs" },
    { lines: [19], notes: "Nele, a propriedade ref espera uma função que recebe a referência ou null (quando se desmonta o componente)" },
    { range: [30, 55], notes: "O createRef é uma nova API que simplifica o acesso a referências" },
    { lines: [32], notes: "Para usar, se cria um objeto Ref de antemão" },
    { lines: [46], notes: "O objeto é passado pra propriedade ref" },
    { range: [36, 38], notes: "E a referência pode ser acessada na propriedade current do objeto Ref" }
  ]}
/>
---
<CodeSurfer
  title="fowardRef"
  code={require("!raw-loader!./samples/forwardRef.jsx")}
  showNumbers={false}
  dark={false}
  steps={[
    {},
    { lines: [3], notes: "forwardRef recebe um componente funcional e passa para ele um `ref` como segundo argumento"},
    { lines: [4], notes: "Esse ref pode ser passado para outros componentes, React ou nativos"},
    { range: [21, 27], notes: "O componente pode ser usado normalmente" },
    { lines: [4], notes: "Mas o conteúdo do `ref` será o <input/>, já que ele recebeu o `ref` de forwardRef" },
    { lines: [13], notes: "O que permite que se dê foco ao <input/> :tada:" },
  ]}
/>
---
# Novos lifecycles
---
# Stric Mode
---
# React 16.4
---
# Pointer Events
```notes
Pointer events are DOM events that are fired for a pointing device. They are designed to create a single DOM event model to handle pointing input devices such as a mouse, pen/stylus or touch (such as one or more fingers).
```
---
# "Bugfix" para getDerivedStateFromProps
```notes
getDerivedStateFromProps is now called every time a component is rendered, regardless of the cause of the update. Previously, it was only called if the component was re-rendered by its parent, and would not fire as the result of a local setState. This was an oversight in the initial implementation that has now been corrected. The previous behavior was more similar to componentWillReceiveProps, but the improved behavior ensures compatibility with React’s upcoming asynchronous rendering mode.
```
---
# React 16.5
---
# Profiler
<img src={require("file-loader!./assets/profiler.png")}/>
---
# React 16.6
---
# React.memo
<CodeSurfer
  title="React.memo"
  code={require("!raw-loader!./samples/memo.jsx")}
  showNumbers={false}
  dark={false}
  steps={[
    { range: [1, 5], notes: "Como é em classes" },
    { range: [7, 9], notes: "E agora a nova feature para funções..." },
  ]}
/>
```notes
Class components can bail out from rendering when their input props are the same using PureComponent or shouldComponentUpdate. Now you can do the same with function components by wrapping them in React.memo.
```
---
<CodeSurfer
  title="Code-Splitting Suspense"
  code={require("!raw-loader!./samples/code-splitting-suspense.jsx")}
  showNumbers={false}
  dark={false}
/>
---
<CodeSurfer
  title="ContextType"
  code={require("!raw-loader!./samples/static-context-type.jsx")}
  showNumbers={false}
  dark={false}
  steps={[
    {},
    { lines: [1], notes: "Instância do contexto" },
    { lines: [4], notes: "Atribuição do contexto" },
    { lines: [6], notes: "Consultando contexto" },
  ]}
/>

```notes
We’ve heard feedback that adopting the new render prop API can be difficult in class components. So we’ve add a convenience API to consume a context value from within a class component.
```

---

# React 16.7 (alpha)

---

# Hooks

---

# O Problema

---

# A Solução

---

# Concurrent React

---

# Time-slicing

---

# Suspense
